## Generate gRPC classes for Python

Our gRPC service is defined using protocol buffers so first you need to generate the gRPC client and server interfaces from .proto service definition.
\
In the `anonymizer` and `analyzer` folder use the following command to generate the Python code:

```bash
python -m grpc_tools.protoc --proto_path=. ./proto/model.proto --python_out=. --grpc_python_out=.
```

## Presidio Anonymizer

The Anonymizer Service has six service methods

```protobuf
service AnonymizerEntity {
    rpc sendRecognizerResults(stream RecognizerResult) returns (FileAck);
    rpc sendAnonymizedItems(stream AnonymizedItem) returns (FileAck);
    rpc sendConfig(Config) returns (FileAck);
    rpc sendFile(stream DataFile) returns (FileAck);
    rpc getText(Request) returns (stream DataFile);
    rpc getItems(Request) returns (stream Item);
}
```

- `sendRecognizerResults` </br> is used by the data loader to send the found entities in the text. RecognizerResult is an exact copy of the RecognizerResult object from presidio-analyzer. Indeed the message contains the start location of the detected entity, the end location of the detected entity, the score of the detection and the type of the entity.

    ```protobuf
    message RecognizerResult {
        int32 start = 1;
        int32 end = 2;
        float score = 3;
        string entity_type = 4;
        string uuidClient = 5; 
    }
    ```

- `sendAnonymizedItems` </br> is used by the data loader to send a list of information about the anonymized entities to perform deanoymization. In this case the message contains the start index of the changed text, the end index of the changed text and the type of the entity.

    ```protobuf
    message AnonymizedItem {
        int32 start = 1;
        int32 end = 2;
        string entity_type = 3;
        string operator = 4;
        string uuidClient = 5; 
    }
    ```

- `sendConfig`</br> is used to send the operator configuration. Possible operators for the anonymizer are:
    1. encrypt - anonymize the text with an encrypted text using Advanced Encryption Standard
    2. replace - replaces the PII text entity with a new string
    3. redact - redact the string - empty value
    4. mask - mask a given amount of text with a given character
    5. hash - hash given text with sha256/sha512/md5 algorithm

    The configuration file is called `operatorConfigAnonymizer` and resides in the `config` folder.</br>
    
    Insted for deanonymization is supported only one operator:
    1. decrypt: decrypt text to from its encrypted form using the key supplied by the user for the encryption

    The configuration file is called `operatorConfigDeanonymizer` and resides in the `config` folder. 

- `sendFile` </br> is used by the data loader to send the original text file that needs to be anonymized. Files will be divided into chunks. The server will assign a UUID that will be used during all the communication to identify uniquely the client information.

- `getText` </br> The client specifies his UUID and specifies the type of request (anonymization or deanonymization). For anonymization the result will be saved into a file called `"filename-anonymized.txt"` which resides in the `anonymized-results` folder. Instead, for deanonymization the result will be saved into a file called `"filename-deanoymized.txt"` that resides in the same folder.

- `getItems` </br> The client specifies his UUID and makes a request to get items. Anonymize() and Deanonymize() function returns the anonymized text and a list of items that contains information about the anonymized/deanonymized entities. For anonymization the result will be saved into a file called `"filename-anonymized-items.txt"` which is contained in the `anonymized-results` folder. Instead, for deanonymization the result will be saved into a file called `"filename-deanonymized-items.txt"` which is contained in the same folder.

## Installation

To run examples:

    $ git clone https://github.com/biagiocornacchia/microsoft-presidio.git
    
    $ pip3 install --upgrade pip
    $ pip3 install presidio-anonymizer
    $ pip3 install spacy numpy

    $ python3 -m spacy download en_core_web_lg
    $ python3 -m pip install grpcio grpcio-tools

From the `microsoft-presidio/anonymizer` directory:

1) Run the server
    ```console
    $ python anonymizer_server.py
    ```
2) From another terminal, run the client (dataloader)
    ```console
    $ python data_loader.py
    ```
    or (to run the graphical user interface)
    ```console
    $ python clientGUI.py
    ```
Now you have just run a client-server application with gRPC!

## An example of anonymization

File demo2.txt (which resides in the `files` folder) contains
        
    Kate's social security number is 078-05-1126.  Her driver license? it is 1234567A.

File demo2-results.txt contains the output generated by the analyzer

    { "start": 0, "end": 4, "score": 0.85, "entity_type": "PERSON" }
    { "start": 33, "end": 44, "score": 0.85, "entity_type": "US_SSN" }
    { "start": 73, "end": 81, "score": 0.65, "entity_type": "US_DRIVER_LICENSE" }

First you have to configure the server (in this example localhost:8061)

    :::::::::::::::::: PRESIDIO ANONYMIZER (data loader) ::::::::::::::::::

    1) Anonymize
    2) Deanonymize
    3) Server configuration
    4) Quit

    Command: 3

    =============== Server config ===============

    IP ADDRESS: localhost
    SERVER PORT: 8061

Select `anonymize` (command 1) and setup a configuration file for the anonymizer.
</br></br>NOTE: setup a configuration is optional. When performing anonymization, if anonymizers map is empty the default anonymization operator is "replace" for all entities. The replacing value will be the entity type e.g.: <PHONE_NUMBER>

    SERVER INFO: localhost:8061

    1) Setup config file
    2) Read the current config
    3) Start anonymization
    4) Back

    Command: 1

    =============== Anonymizer Operator config (Ctrl-C for exit) ===============

    Entity: PERSON
    Anonymizer: encrypt
    Key (128, 192 or 256 bits length): AAECAwQFBgcICQoLDA0ODw==
    CONFIG: creating a new config file...

So we can start anonymization using command 3 and choosing a file (in this case demo2)

    1) Setup config file
    2) Read the current config
    3) Start anonymization
    4) Back

    Command: 3

    How many files you want to analyze? 1
    1) Filename: demo2

Anonymizer results saved into `anonymizer-results/` folder (anonymizer-results/demo2-anonymized.txt and anonymizer-results/demo2-anonymized-items.txt) will be

    J4I4V8mL4sy2r5DNRqSiN5lQJzU2XLJFhwMNHAh1jmQ='s social security number is <US_SSN>.  Her driver license? it is <US_DRIVER_LICENSE>.
    
    Anonymized items:
    { "operator": "replace", "entity_type": "US_DRIVER_LICENSE", "start": 110, "end": 129, "text": "<US_DRIVER_LICENSE>" }
    { "operator": "replace", "entity_type": "US_SSN", "start": 73, "end": 81, "text": "<US_SSN>" }
    { "operator": "encrypt", "entity_type": "PERSON", "start": 0, "end": 44, "text": "J4I4V8mL4sy2r5DNRqSiN5lQJzU2XLJFhwMNHAh1jmQ=" }

### An example of deanonymization

This example take the output of the AnonymizerEngine with `encrypted` PII entity, and decrypts it back to the original text.

Firstly, we have to setup a config file specifying the cryptographic key used for the encryption (in this case `key = AAECAwQFBgcICQoLDA0ODw==`)
        
    1) Setup config file
    2) Read the current config
    3) Start deanonymization
    4) Back

    Command: 1

    =============== Deanonymizer Operator config (Ctrl-C for exit) ===============

    Entity: PERSON
    Anonymizer: decrypt
    Key (128, 192 or 256 bits length): AAECAwQFBgcICQoLDA0ODw==
    CONFIG: creating a new config file...

Deanonymizer results saved into `anonymizer-results/` folder (anonymizer-results/demo2-deanonymized.txt and anonymizer-results/demo2-deanonymized-items.txt) will be

    Kate's social security number is <US_SSN>.  Her driver license? it is <US_DRIVER_LICENSE>.
    
    Items:
    { "start": 0, "end": 4, "operator": "decrypt", "text": "Kate", "entity_type": "NUMBER" }

## Scheme API

`anonymizer_client.py` contains a ClientEntity class.

### Global vars

```python
SUPPORTED_ENTITIES = ['IBAN_CODE', 'US_PASSPORT', 'DATE_TIME', 'MEDICAL_LICENSE', 'CRYPTO', 'LOCATION', 'UK_NHS', 'US_SSN', 'CREDIT_CARD', 'US_BANK_NUMBER', 'US_ITIN', 'EMAIL_ADDRESS', 'PERSON', 'IP_ADDRESS', 'DOMAIN_NAME', 'PHONE_NUMBER', 'SG_NRIC_FIN', 'NRP', 'US_DRIVER_LICENSE']
ANONYMIZERS = ['hash', 'mask', 'redact', 'replace', 'custom', 'encrypt', 'decrypt']

CONFIG_FILE = 'config/operatorConfigAnonymizer.txt'
CONFIG_FILE_DE = 'config/operatorConfigDeanonymizer.txt'

PATH_ANONYMIZER_RESULTS = "../anonymizer-results/"
PATH_ANALYZER_RESULTS = "../analyzer-results/"
PATH_FILES = "../files/"
```

* `SUPPORTED_ENTITIES` and `ANONYMIZERS` are the list of entities and anonymizers supported by Microsoft Presidio.</br>
* `CONFIG_FILE` and `CONFIG_FILE_DE` contains the path of the configuration files. One used by the anonymizer and one used during the deanoymization.</br>
* `PATH_ANONYMIZER_RESULTS`, `PATH_ANALYZER_RESULTS` and `PATH_FILES` are the directories where the anonymizer results will be saved and where the orignal text resides.

### Connection 
You should first establish a connection between the gRPC anonymizer client and the gRPC anonymizer server. Here are two functions to manage connections:

```python
class ClientEntity:

    def __init__(self, ip_address, port):

        self.ip_address = ip_address
        self.port = port
        self.channel = grpc.insecure_channel(ip_address + ':' + str(port))
        self.stub = pb2_grpc.AnonymizerEntityStub(self.channel)
        .
        .
        .

    def closeConnection(self):
        print("Disconnected from the server")
        self.channel.close()
```

The arguments are a string that denote the server ip address and a number to denote the server port.

### Start anonymization/deanonymization

```python
class ClientEntity:
        .
        .
    def sendRequestAnonymize(self, filename):
    def sendRequestDeanonymize(self, filename):
    def sendRequestForText(self, filename, uuidClient, requestType):
    def sendRequestForItems(self, filename, uuidClient, requestType):
        .
        .
```
To perform anonymization/deanonymization there are four function:
1. `sendRequestAnonymize(filename)` </br>This function takes an argument (a filename) and (after a check of the required files) sends the original text file, the analyzer results and eventually a configuration file. Then makes a request for the anonymized text and anonymized items. </br> It returns an integer:
    * if some required files do not exist or the request for text/items fails returns -1
    * if there is a gRPC exception such as 'server unavailable' returns -2
    * if some required files were not received correctly by the server return 0
    * if the operation was successful returns 1

2. `sendRequestDeanonymize(filename)` </br> This function takes an argument (a filename) and (after a check of the required files) sends the anonymized text file, the anonymizer results and a configuration file (in this case is required because you have to specify a key for decrypt). Then makes a request for the deanonymized text and denonymized items. </br> It returns an integer:
    * if some required files do not exist returns -1
    * if there is a gRPC exception such as 'server unavailable' returns -2
    * if some required files were not received correctly by the server return 0
    * if the operation was successful returns 1

3. `sendRequestForText(filename, uuidClient, requestType)` </br>This function takes three arguments (a filename, uuidClient assigned by the server and a requestType that can be 'anonymize' or 'deanonymize') and sends a request to get anonymized or deanonymized text. </br> It returns an integer:
    * if the request for the anonymized/deanonymized text fails returns -1
    * if the operation was successful returns 1

4. `sendRequestForItems(filename, uuidClient, requestType)` </br>This function takes three arguments (a filename, uuidClient assigned by the server and a requestType that can be 'anonymize' or 'deanonymize') and sends a request to get anonymized or deanonymized items. </br> It returns an integer:
    * if the request for the anonymized/deanonymized items fails returns -1
    * if the operation was successful returns 1

### Setup a configuration

`anonymizer_client.py` has also some utility functions used to setup the anonymizer configuration. For each operator exists a function called `addName-Operator()`. For example:

```python
# replaces the PII text entity with new string.
def addReplace(entity_type, new_value):
    # check for duplicate
    found = checkDuplicate(entity_type, CONFIG_FILE)

    params = '{ ' + f'\\"type\\": \\"replace\\", \\"new_value\\": \\"{new_value}\\"' + ' }'

    with open(CONFIG_FILE, 'a') as f:
        f.write("{ " + f'"entity_type" : "{entity_type}", "params" : "{params}"' + " }\n")

    return found

# anonymizes text to an encrypted form
def addEncrypt(entity_type, key):
    # check for duplicate
    found = checkDuplicate(entity_type, CONFIG_FILE)

    params = '{ ' + f'\\"type\\": \\"encrypt\\", \\"key\\": \\"{key}\\"' + ' }'

    with open(CONFIG_FILE, 'a') as f:
        f.write("{ " + f'"entity_type" : "{entity_type}", "params" : "{params}"' + " }\n")

    return found
    .
    .
    .
```

Other utility functions are:
1. checkDuplicate(entity_type, configFile)
2. anonymizerOptions(anonymizer, configType)

`checkDuplicate` is used to check if a config option is already setted in the specified configuration file (CONFIG_FILE or CONFIG_FILE_DE) and returns an integer which indicates if an opition was rewritten or not. <br> While `anonymizerOptions` has two arguments. Anonymizer (for example encrypt,hash,replace ecc) and configType (Anonymizer or Deanonymizer). This function will ask for some other input values and returns a string based on the type of anonymizer.

### Example of anonymization

```python
import anonymizer_client as anonymizer

if __name__ == "__main__":

    clientAnonymizer = anonymizer.ClientEntity("localhost", 8061)
    clientAnonymizer.readConfiguration(anonymizer.CONFIG_FILE)
    
    # Setup operator config
    print("Hash configuration\n")
    entity_type = input("Entity: ").upper()
    hash_type = input("Hash type (md5, sha256, sha512): ").lower()

    anonymizer.addHash(entity_type, hash_type)

    # Send request for anonymization
    result = clientAnonymizer.sendRequestAnonymize("demo")
    
    if result == -2:
        print("gRPC Server Error: cannot connect to the server! Check your server settings")
    elif result == -1:
        print("gRPC Server Error: original file text or analyzer results not found!")

    clientAnonymizer.closeConnection()
```

### Example of deanonymization

```python
import anonymizer_client as anonymizer

if __name__ == "__main__":

    clientAnonymizer = anonymizer.ClientEntity("localhost", 8061)
    clientAnonymizer.readConfiguration(anonymizer.CONFIG_FILE_DE)

    # Setup deanonymizer configuration file    
    print("Decrypt configuration\n")
    entity_type = input("Entity: ").upper()
    key = input("Key (must be of length 128, 192 or 256 bits): ")

    anonymizer.addDecrypt(entity_type, key)

    # Send request for deanonymization
    result = clientAnonymizer.sendRequestDeanonymize("demo-anonymized")
    
    if result == -2:
        print("gRPC Server Error: cannot connect to the server! Check your server settings")
    elif result == -1:
        print("gRPC Server Error: anonymized file text or anonymizer results not found!")

    clientAnonymizer.closeConnection()

```

## Deployment
From the microsoft-presidio/anonymizer directory

1) Build the docker image
```console
docker build -t grpc-anonymizer .
```
2) Run the docker image
```console
docker run â€“dp 8061:8061 grpc-anonymizer
```
3) The docker run internally executes anonymizer_server.py. Open one more terminal and run the client which now can access the docker server
```console
python data_loader.py
```
